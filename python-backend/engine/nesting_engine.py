"""
nesting_engine.py  —  True-Shape Free-Space Nesting (MaxRects + Best-Fit + Curve-Space)
========================================================================================

Algorithm
---------
1.  Expand every part's quantity into individual pieces (flat list).
2.  Sort pieces by area descending — largest parts are placed first.
3.  Maintain a MaxRects-style free-rectangle list per sheet.
    For each piece and each rotation two candidate sets are merged:

    A. FREE-RECT CORNERS (rectangular free space)
       Bottom-left corners of every free rect large enough for the part's
       rotated bounding box.  Scored by leftover = rect_area − bbox_area.

    B. CURVE-SPACE CANDIDATES (arc / circle gap fill)  ← NEW
       Actual boundary vertices of every already-placed polygon are sampled.
       Offsetting each vertex by the clearance margin in four directions
       yields positions that sit INSIDE a placed part's bounding box but
       OUTSIDE its real polygon — the "curve space" left by circles and arcs.
       These positions are never generated by set A because the free-rect
       list is split on bounding boxes, not actual shapes.
       Scored with leftover = −1.0 (highest priority in best-fit ordering)
       when not covered by any free rect; otherwise scored by the smallest
       covering free rect's leftover.

    Both sets are merged, deduplicated, and sorted by leftover ascending.
    The first candidate that passes the true-shape Shapely collision check
    (STRtree on actual polygon geometry) is accepted.

4.  Before opening a new sheet, ALL existing sheets are evaluated with the
    same best-fit metric.  The globally tightest fit wins.  A new sheet is
    opened only when no existing sheet can accept the part.

Public API unchanged — main.py requires no modifications.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Optional

from shapely.geometry import Polygon as ShapelyPolygon
from shapely.affinity import (
    translate as shapely_translate,
    rotate    as shapely_rotate,
)
from shapely.strtree import STRtree


# ================================================================
# PUBLIC DATA STRUCTURES  (field names must not change)
# ================================================================

Point    = tuple[float, float]
Polygon  = list[Point]
FreeRect = tuple[float, float, float, float]   # (x, y, width, height)


@dataclass
class PolygonPart:
    """
    One unique part shape with a repeat quantity.

    Fields used by main.py (must not be renamed):
        id, outer, holes, quantity, area

    file_name is optional metadata forwarded to each placement dict.
    Defaults to the id value when not provided.
    """
    id:        str
    outer:     Polygon
    holes:     list[Polygon] = field(default_factory=list)
    quantity:  int           = 1
    area:      float         = 0.0
    file_name: Optional[str] = field(default=None)


@dataclass
class StockSheet:
    """Rectangular material sheet."""
    width:     float
    height:    float
    thickness: float = 0.0


@dataclass
class NestingConfig:
    """Nesting parameters."""
    step_x:        float       = 5.0
    step_y:        float       = 5.0
    margin:        float       = 0.0
    rotations:     list[float] = field(default_factory=lambda: [0.0, 90.0])
    advanced_mode: bool        = False
    rotation_step: float       = 10.0
    n_passes:      int         = 5
    edge_gap:      float       = 0.0   # minimum clearance from sheet boundary


# ================================================================
# INTERNAL PER-SHEET STATE
# ================================================================

@dataclass
class _SheetState:
    """Mutable state for one sheet, maintained across placements."""
    sheet_idx:       int
    placements:      list[dict]
    placed_polys:    list[ShapelyPolygon]   # actual placed shapes (sheet coords)
    placed_buffered: list[ShapelyPolygon]   # margin-buffered shapes
    tree:            Optional[STRtree]      # STRtree over placed_buffered
    free_rects:      list[FreeRect]         # MaxRects free-space list


# ================================================================
# FREE-SPACE HELPERS  (MaxRects guillotine split)
# ================================================================

def _update_free_rects(
    free_rects: list[FreeRect],
    px: float, py: float, pw: float, ph: float,
    margin: float,
) -> list[FreeRect]:
    """
    Update the free-rectangle list after placing a part whose bounding
    box on the sheet spans (px, py) → (px+pw, py+ph).

    Every free rect that overlaps the placed bbox (expanded by the
    clearance margin) is removed and replaced by up to four non-
    overlapping sub-rects covering the still-free area.
    Dominated rects (entirely inside a larger one) are pruned.
    """
    bx1 = max(0.0, px - margin)
    by1 = max(0.0, py - margin)
    bx2 = px + pw + margin
    by2 = py + ph + margin

    result: list[FreeRect] = []

    for (rx, ry, rw, rh) in free_rects:
        rx2 = rx + rw
        ry2 = ry + rh

        # No overlap with placed bbox → keep unchanged
        if bx1 >= rx2 or bx2 <= rx or by1 >= ry2 or by2 <= ry:
            result.append((rx, ry, rw, rh))
            continue

        # Overlap: guillotine-split into up to four sub-rects
        if rx  < bx1:           # left slice
            result.append((rx,  ry,  bx1 - rx,  rh))
        if rx2 > bx2:           # right slice
            result.append((bx2, ry,  rx2 - bx2, rh))
        if ry  < by1:           # bottom slice
            result.append((rx,  ry,  rw, by1 - ry))
        if ry2 > by2:           # top slice
            result.append((rx,  by2, rw, ry2 - by2))

    return _prune_free_rects(result)


def _prune_free_rects(rects: list[FreeRect]) -> list[FreeRect]:
    """Remove free rects entirely contained within a larger one."""
    result: list[FreeRect] = []
    for i, (ax, ay, aw, ah) in enumerate(rects):
        if aw < 1e-9 or ah < 1e-9:
            continue
        contained = False
        for j, (bx, by, bw, bh) in enumerate(rects):
            if i == j or bw < 1e-9 or bh < 1e-9:
                continue
            if (bx     <= ax + 1e-9 and
                by     <= ay + 1e-9 and
                bx + bw >= ax + aw - 1e-9 and
                by + bh >= ay + ah - 1e-9 and
                bw * bh >  aw * ah + 1e-9):
                contained = True
                break
        if not contained:
            result.append((ax, ay, aw, ah))
    return result


# ================================================================
# CURVE-SPACE HELPERS
# ================================================================

# Maximum boundary vertices sampled per placed polygon.
# Circles in Shapely are approximated with many segments; sampling a subset
# keeps candidate count manageable while covering the arc uniformly.
_N_CURVE_SAMPLES = 16


def _curve_candidates(
    placed_polys: list[ShapelyPolygon],
    pw: float,
    ph: float,
    sheet_width:  float,
    sheet_height: float,
    margin: float,
    edge_gap: float = 0.0,
) -> list[tuple[float, float]]:
    """
    Generate candidate positions from the actual boundaries of placed polygons.

    The MaxRects free-rect list is split on bounding boxes, so the concave
    regions between a curved part's actual shape and its bbox corners are
    NOT represented as free space.  Example: a circle's four bbox corners
    are geometrically empty, but no free rect covers them.

    This function samples each placed polygon's real exterior vertices and
    produces four candidate offsets per vertex — positions where a new part
    could be placed flush against the actual curve boundary.  The STRtree
    collision check in _find_best then decides whether each position is
    truly free.

    Returns a deduplicated list of (x, y) bottom-left candidate positions.
    """
    seen:  set[tuple[float, float]] = set()
    cands: list[tuple[float, float]] = []

    for poly in placed_polys:
        try:
            all_coords = list(poly.exterior.coords)
        except Exception:
            continue

        # Evenly sub-sample to limit candidate count for high-resolution curves
        n = len(all_coords)
        if n > _N_CURVE_SAMPLES + 1:
            step   = max(1, n // _N_CURVE_SAMPLES)
            coords = all_coords[::step]
        else:
            coords = all_coords

        for (vx, vy) in coords:
            # Four offsets relative to each boundary vertex:
            #   right of vertex — new part's left edge touches boundary
            #   above vertex    — new part's bottom edge touches boundary
            offsets = (
                (vx + margin,      vy      ),   # right, bottom-aligned
                (vx + margin,      vy - ph ),   # right, top-aligned
                (vx,               vy + margin), # above, left-aligned
                (vx - pw,          vy + margin), # above, right-aligned
            )
            for cx, cy in offsets:
                if (cx >= edge_gap - 1e-9 and cy >= edge_gap - 1e-9 and
                        cx + pw <= sheet_width  - edge_gap + 1e-9 and
                        cy + ph <= sheet_height - edge_gap + 1e-9):
                    key = (round(cx, 3), round(cy, 3))
                    if key not in seen:
                        seen.add(key)
                        cands.append(key)

    return cands


def _leftover_score(
    cx: float, cy: float,
    pw: float, ph: float,
    free_rects: list[FreeRect],
    bbox_area:  float,
) -> float:
    """
    Compute the best-fit score (minimum leftover) for a candidate position.

    If (cx, cy) is covered by at least one free rect → return the leftover
    of the smallest covering rect  (consistent with the free-rect scoring).

    If (cx, cy) is NOT covered by any free rect → the position is inside a
    bounding-box region that has already been "used" by a placed part, but
    the actual polygon leaves a gap there (curve space).  Return −1.0 to
    give it the highest priority in the best-fit ordering: filling a curve
    space wastes zero additional material.
    """
    best: Optional[float] = None
    for (rx, ry, rw, rh) in free_rects:
        if (rx <= cx + 1e-9 and
                ry <= cy + 1e-9 and
                rx + rw >= cx + pw - 1e-9 and
                ry + rh >= cy + ph - 1e-9):
            lv = rw * rh - bbox_area
            if best is None or lv < best:
                best = lv
    # Curve space (not covered by any free rect): perfect fit priority
    return best if best is not None else -1.0


# ================================================================
# PLACEMENT CORE
# ================================================================

# Return type for _find_best: (leftover_area, x, y, angle, placed_polygon)
_BestResult = tuple[float, float, float, float, ShapelyPolygon]


def _find_best(
    raw_poly:        ShapelyPolygon,
    rotations:       list[float],
    sheet_width:     float,
    sheet_height:    float,
    free_rects:      list[FreeRect],
    placed_polys:    list[ShapelyPolygon],   # actual shapes → curve-space candidates
    placed_buffered: list[ShapelyPolygon],   # margin-buffered shapes → collision
    tree:            Optional[STRtree],      # STRtree over placed_buffered
    margin:          float,
    step_x:          float = 5.0,            # kept for API compatibility, unused
    step_y:          float = 5.0,            # kept for API compatibility, unused
    edge_gap:        float = 0.0,            # minimum clearance from sheet boundary
) -> Optional[_BestResult]:
    """
    Find the BEST-FIT placement for raw_poly across all rotations.

    For each rotation two candidate sets are merged:
      A. Free-rect corner candidates — scored by leftover (rect_area − bbox_area).
      B. Curve-space candidates — actual polygon boundary vertices offset by
         the clearance margin, scored −1.0 (highest priority) when they fall
         outside all free rects (pure curve gap), or by the smallest covering
         free rect's leftover otherwise.

    The merged set is sorted by leftover ascending (best-fit) and tried in
    that order.  The first candidate that passes the true-shape Shapely
    collision check (STRtree) is the best for this rotation.  The global
    minimum across all rotations is returned.

    Returns (leftover, x, y, angle, placed_polygon) or None.
    """
    _PROBE_SHRINK = 1e-4
    best: Optional[_BestResult] = None

    usable_w = max(0.0, sheet_width  - 2.0 * edge_gap)
    usable_h = max(0.0, sheet_height - 2.0 * edge_gap)

    for angle in rotations:
        rotated = shapely_rotate(raw_poly, angle, origin='centroid', use_radians=False)
        minx, miny, maxx, maxy = rotated.bounds
        pw = maxx - minx
        ph = maxy - miny

        if pw > usable_w + 1e-9 or ph > usable_h + 1e-9:
            continue   # part does not fit the usable area at this rotation

        # Normalise: bounding box starts at (0, 0)
        normalized = shapely_translate(rotated, -minx, -miny)
        bbox_area  = pw * ph

        # ── Candidate set A: free-rect corners (best-fit scored) ────────────
        # Dict deduplicates positions; keeps the lowest leftover per position.
        all_cands: dict[tuple[float, float], float] = {}   # (x, y) → leftover

        for (rx, ry, rw, rh) in free_rects:
            if (rw + 1e-9 >= pw and rh + 1e-9 >= ph and
                    rx + pw <= sheet_width  - edge_gap + 1e-9 and
                    ry + ph <= sheet_height - edge_gap + 1e-9):
                lv  = rw * rh - bbox_area
                key = (round(rx, 4), round(ry, 4))
                if key not in all_cands or lv < all_cands[key]:
                    all_cands[key] = lv

        # ── Candidate set B: curve-space positions (polygon boundary) ────────
        # Generated only when at least one part has been placed.
        if placed_polys:
            for (cx, cy) in _curve_candidates(
                placed_polys, pw, ph, sheet_width, sheet_height, margin, edge_gap
            ):
                lv  = _leftover_score(cx, cy, pw, ph, free_rects, bbox_area)
                key = (round(cx, 4), round(cy, 4))
                if key not in all_cands or lv < all_cands[key]:
                    all_cands[key] = lv

        # ── Sort merged candidates by leftover ascending (best-fit) ─────────
        eligible = sorted(
            [(lv, x, y) for (x, y), lv in all_cands.items()],
            key=lambda e: e[0],
        )

        for leftover, x, y in eligible:
            # Early-exit: no remaining candidate for this rotation can beat
            # the global best already found across all rotations.
            if best is not None and leftover >= best[0]:
                break

            candidate = shapely_translate(normalized, x, y)

            # No placed parts yet → trivially valid (empty sheet)
            if tree is None:
                best = (leftover, x, y, angle, candidate)
                break

            # True-shape collision check — Shapely STRtree on actual polygons.
            # Shrink probe by epsilon so flush boundary-touching parts
            # (margin=0) are NOT flagged as intersecting.
            probe = candidate.buffer(-_PROBE_SHRINK)
            if probe.is_empty:
                probe = candidate

            if len(tree.query(probe, predicate='intersects')) == 0:
                best = (leftover, x, y, angle, candidate)
                break   # best valid for this rotation found

    return best


def _apply_placement(
    state:     _SheetState,
    piece:     dict,
    x:         float,
    y:         float,
    angle:     float,
    candidate: ShapelyPolygon,
    margin:    float,
) -> None:
    """Commit a placement to a sheet state (mutates in place)."""
    bx1, by1, bx2, by2 = candidate.bounds
    pw = bx2 - bx1
    ph = by2 - by1

    state.placements.append({
        "file_name": piece["file_name"],
        "part_id":   piece["part_id"],
        "x":         round(x, 4),
        "y":         round(y, 4),
        "rotation":  angle,
    })

    state.placed_polys.append(candidate)

    buffered = candidate.buffer(margin, resolution=4) if margin > 0 else candidate
    state.placed_buffered.append(buffered)

    # Rebuild STRtree (runs in C — sub-millisecond for typical counts)
    state.tree = STRtree(state.placed_buffered)

    # Guillotine-split the free-rectangle list around the placed bbox.
    # Note: the free-rect split uses the bbox, not the actual polygon.
    # Curve-space candidates fill the difference via candidate set B above.
    state.free_rects = _update_free_rects(
        state.free_rects, x, y, pw, ph, margin
    )


# ================================================================
# PUBLIC API
# ================================================================

def nest_parts(
    parts:  list[PolygonPart],
    sheet:  StockSheet,
    config: Optional[NestingConfig] = None,
) -> dict:
    """
    True-shape free-space nesting — Largest-First + Best-Fit + Curve-Space fill.

    Parts are sorted by area descending before placement.
    For each part, every existing sheet is queried; the placement with the
    minimum leftover area (globally across all sheets and rotations) is chosen.
    Curve spaces beside arcs and circles are filled via polygon boundary
    sampling before any new sheet is opened.

    Returns
    -------
    {
        "sheets":              [ { "sheet_index", "width", "height",
                                   "placements": [...] } ],
        "sheets_required":     int,
        "utilization_percent": float,
        "waste_percent":       float,
        "waste":               float,  # alias for frontend
        "oversized_parts":     [str, ...],
        "total_sheets":        int,
        "utilization":         float,
        "capacity_per_sheet":  int,
    }
    """
    if config is None:
        config = NestingConfig()

    sheet_width  = sheet.width
    sheet_height = sheet.height

    # ── Validate sheet ──────────────────────────────────────────────────────
    if sheet_width <= 0 or sheet_height <= 0:
        return {
            "error":               "Sheet dimensions must be positive.",
            "sheets":              [],
            "sheets_required":     0,
            "total_sheets":        0,
            "utilization":         0.0,
            "utilization_percent": 0.0,
            "waste_percent":       100.0,
            "waste":               100.0,
            "oversized_parts":     [],
            "capacity_per_sheet":  0,
        }

    margin    = max(config.margin,    0.0)
    step_x    = max(config.step_x,   0.1)
    step_y    = max(config.step_y,   0.1)
    rotations = config.rotations if config.rotations else [0.0]
    edge_gap  = max(getattr(config, 'edge_gap', 0.0), 0.0)

    usable_width  = max(0.0, sheet_width  - 2.0 * edge_gap)
    usable_height = max(0.0, sheet_height - 2.0 * edge_gap)

    # ── Step 1: build Shapely polygons and expand by quantity ───────────────
    pieces:    list[dict] = []
    oversized: list[str]  = []

    for part in parts:
        if not part.outer or len(part.outer) < 3:
            continue

        try:
            raw = ShapelyPolygon(part.outer)
            if not raw.is_valid:
                raw = raw.buffer(0)      # attempt self-intersection repair
            if raw.is_empty or raw.area == 0:
                continue
        except Exception:
            continue

        # Pre-check: fits in at least one rotation (within usable area)?
        fits_sheet = False
        for angle in rotations:
            rot = shapely_rotate(raw, angle, origin='centroid', use_radians=False)
            bx1, by1, bx2, by2 = rot.bounds
            if ((bx2 - bx1) <= usable_width  + 1e-9 and
                    (by2 - by1) <= usable_height + 1e-9):
                fits_sheet = True
                break

        if not fits_sheet:
            oversized.append(part.id)
            continue

        fname = part.file_name if part.file_name else part.id
        qty   = max(int(part.quantity), 1)
        for _ in range(qty):
            pieces.append({"part_id": part.id, "file_name": fname, "poly": raw})

    # ── Step 2: largest area first (best packing base order) ────────────────
    pieces.sort(key=lambda p: p["poly"].area, reverse=True)

    # ── Step 3: place pieces — Best-Fit + Curve-Space across all sheets ─────
    all_sheets:        list[_SheetState] = []
    total_placed_area: float             = 0.0

    def _new_sheet() -> _SheetState:
        return _SheetState(
            sheet_idx       = len(all_sheets),
            placements      = [],
            placed_polys    = [],
            placed_buffered = [],
            tree            = None,
            free_rects      = [(edge_gap, edge_gap, usable_width, usable_height)],
        )

    current = _new_sheet()

    for piece in pieces:
        raw_poly = piece["poly"]

        # Collect best-fit candidate from every sheet (current + completed).
        # Each entry: (leftover, sheet_state, x, y, angle, candidate_polygon)
        sheet_candidates: list[
            tuple[float, _SheetState, float, float, float, ShapelyPolygon]
        ] = []

        def _query(state: _SheetState) -> None:
            result = _find_best(
                raw_poly, rotations, sheet_width, sheet_height,
                state.free_rects,
                state.placed_polys,    # actual shapes for curve-space candidates
                state.placed_buffered,
                state.tree,
                margin, step_x, step_y, edge_gap,
            )
            if result is not None:
                leftover, x, y, angle, candidate = result
                sheet_candidates.append(
                    (leftover, state, x, y, angle, candidate)
                )

        _query(current)
        for prev in all_sheets:
            _query(prev)

        if sheet_candidates:
            # Select the globally tightest fit (minimum leftover)
            sheet_candidates.sort(key=lambda c: c[0])
            leftover, best_state, x, y, angle, candidate = sheet_candidates[0]
            _apply_placement(best_state, piece, x, y, angle, candidate, margin)
            total_placed_area += raw_poly.area

        else:
            # No existing sheet can accept this part → open a new one
            all_sheets.append(current)
            current = _new_sheet()

            result = _find_best(
                raw_poly, rotations, sheet_width, sheet_height,
                current.free_rects,
                current.placed_polys,
                current.placed_buffered,
                current.tree,
                margin, step_x, step_y, edge_gap,
            )
            if result is not None:
                leftover, x, y, angle, candidate = result
                _apply_placement(current, piece, x, y, angle, candidate, margin)
                total_placed_area += raw_poly.area
            else:
                # Truly cannot fit anywhere (pre-check should prevent this)
                if piece["part_id"] not in oversized:
                    oversized.append(piece["part_id"])

    # Append the last active sheet if it has placements
    if current.placements:
        all_sheets.append(current)

    # ── Step 4: utilisation (actual polygon area, not bbox) ─────────────────
    sheets_list = [
        {
            "sheet_index": s.sheet_idx,
            "width":       sheet_width,
            "height":      sheet_height,
            "placements":  s.placements,
        }
        for s in all_sheets
    ]

    sheets_required     = len(sheets_list)
    total_sheet_area    = sheets_required * sheet_width * sheet_height
    utilization_percent = (
        round(total_placed_area / total_sheet_area * 100, 2)
        if total_sheet_area > 0 else 0.0
    )
    waste_percent = round(100.0 - utilization_percent, 2)

    return {
        "sheets":              sheets_list,
        "sheets_required":     sheets_required,
        "utilization_percent": utilization_percent,
        "waste_percent":       waste_percent,
        "waste":               waste_percent,   # alias used by frontend
        "oversized_parts":     oversized,
        # Backward-compat aliases
        "total_sheets":        sheets_required,
        "utilization":         utilization_percent,
        "capacity_per_sheet":  0,
    }


# ================================================================
# BACKWARD-COMPATIBILITY STUBS
# ================================================================

def _try_place(
    raw_poly:        ShapelyPolygon,
    rotations:       list[float],
    sheet_width:     float,
    sheet_height:    float,
    free_rects:      list[FreeRect],
    placed_buffered: list[ShapelyPolygon],
    tree:            Optional[STRtree],
    margin:          float,
    step_x:          float = 5.0,
    step_y:          float = 5.0,
) -> Optional[tuple[float, float, float, ShapelyPolygon]]:
    """Thin wrapper around _find_best for callers that expect the old signature."""
    result = _find_best(
        raw_poly, rotations, sheet_width, sheet_height,
        free_rects,
        [],             # no placed_polys in old interface — curve-space disabled
        placed_buffered, tree, margin, step_x, step_y,
    )
    if result is None:
        return None
    _, x, y, angle, candidate = result
    return x, y, angle, candidate


def part_from_geometry(
    part_id:  str,
    geometry: list,
    quantity: int = 1,
) -> Optional[PolygonPart]:
    """Build a PolygonPart from a geometry list produced by dxf_parser."""
    if not geometry:
        return None
    for item in geometry:
        pts = item.get("points", [])
        if len(pts) >= 3:
            return PolygonPart(
                id       = part_id,
                outer    = [(float(p[0]), float(p[1])) for p in pts],
                quantity = quantity,
            )
    return None


def compute_polygon_area(pts: Polygon) -> float:
    """Absolute area via the shoelace formula."""
    n = len(pts)
    if n < 3:
        return 0.0
    s = 0.0
    for i in range(n):
        x0, y0 = pts[i][0],           pts[i][1]
        x1, y1 = pts[(i + 1) % n][0], pts[(i + 1) % n][1]
        s += x0 * y1 - x1 * y0
    return abs(s) / 2.0


def polygon_collision(poly1: Polygon, poly2: Polygon) -> bool:
    """Check polygon collision using Shapely."""
    try:
        p1 = ShapelyPolygon(poly1)
        p2 = ShapelyPolygon(poly2)
        return bool(p1.intersects(p2))
    except Exception:
        return False


def polygons_intersect(
    poly1:     Polygon,
    poly2:     Polygon,
    clearance: float = 0.0,
) -> bool:
    """Check polygon intersection with optional clearance using Shapely."""
    try:
        p1 = ShapelyPolygon(poly1)
        p2 = ShapelyPolygon(poly2)
        if clearance > 0:
            p1 = p1.buffer(clearance / 2)
        return bool(p1.intersects(p2))
    except Exception:
        return False
